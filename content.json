{"meta":{"title":"Yushen's Note","subtitle":"","description":"Learning","author":"Yushen_L","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-08-15T15:29:03.605Z","updated":"2020-08-15T11:01:01.741Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-16T11:07:06.727Z","updated":"2020-08-15T11:01:01.745Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-24T09:58:53.938Z","updated":"2020-08-24T09:58:53.938Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-15T15:44:21.401Z","updated":"2020-08-15T11:01:01.747Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"一份自我介绍","date":"2021-08-16T02:55:18.238Z","updated":"2021-08-16T02:55:18.238Z","comments":false,"path":"introduction/index.html","permalink":"http://yoursite.com/introduction/index.html","excerpt":"","text":"YuShen yushen_l@163.com 教育背景 华中科技大学 机械工程 流体传动控制系 | 2020.9 - … 武汉理工大学 机械设计制造及其自动化 | 2016.9-2020.6 项目经验 硕士阶段 疏水系统噪声预报系统： 纵向项目，已完成泵源特性分析 皮囊式管道消声器设计： 横向项目，交付完成，负责声学仿真，结构设计，及部分流体动力学仿真 舱底泵组故障诊断分析： 横向项目，目前在研，负责自主研发柱塞泵的FMEA分析及故障树的绘制，撰写维修说明 集中冷却系统管道噪声分析： 横向项目，目前在研，负责管路一维仿真、三维声学仿真，及出口射流噪声仿真 本科阶段 全国大学生机械创新设计大赛 ： 获得国家一等奖，负责整体设计，力学分析，机加工及文案撰写。 国家创新创业基金《一种多功能助行机器人》创新训练项目： 项目成功结题，负责专利撰写、机加工。 国家创新创业基金《一种分合式海上原油清理船》创新训练项目： 项目成功结题，负责担三维模型建立及文案撰写工作。 自主创新基金《新型蒸发式冷风机》项目 ： 项目成功结题，负责文案撰写。 实习经历 暂无 其他 技能：ETC6、Office、Adobe、C++ 学校经历：校港口协会会长、学生会科协副部"},{"title":"关于这个网站","date":"2020-08-17T04:10:54.233Z","updated":"2020-08-17T04:10:54.233Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"· 关于开始 About Start 因为假期在学习C和QT知识，OneNote等电子笔记并不方便保存程序，受到朋友们的影响，于是尝试着建立了这个网站，用于保存在学习CPrimer时做的练习，同时整理学习笔记。因为这个网站是出于学习目的建设的，所以想要先做成一个笔记本的样子。我在编程方面是小白一枚，欢迎大家指正错误，一起讨论交流！ · 关于计划 About Plan 除了学习笔记之外，我打算之后打算慢慢地对自己以往的一些项目和作品进行归纳和总结，做成帮助文档记录在这个网站上。因为将要步入研究生阶段了，想要借这个网站的建设过程来进一步了解自己做。之后把这个网站做成类似于简历的样子，作为自己一个信息中心，链接到我其他的一些网站像bilibili，就能在一些可能场合全面的介绍自己了。 · 关于本人 About Me 一名准研究生，一只好像什么都会一点，但好像又什么都不会的菜鸟。目前主要研究工程控制的检测系统，辅修流体学声和液压系统，偶尔会做些视频自嗨一下。关于本人的详细情况可以戳→这里 编写于2020年8月17日"}],"posts":[{"title":"AmeSim学习笔记","slug":"simulation/AmeSim_solver","date":"2022-02-28T08:30:20.000Z","updated":"2022-03-17T10:01:46.851Z","comments":true,"path":"posts/simulation/AmeSim_solver.html","link":"","permalink":"http://yoursite.com/posts/simulation/AmeSim_solver.html","excerpt":"","text":"软件使用方法比较简单不做介绍，本文主要记录个人项目中使用到的一些模型资料方便翻找（均可在help说明书中找到） 方程求解 连续性方程组 常见的显式微分方程可通过**Explicit Runge-Kutta（显式龙格库塔）**求解，但该方法不适用于隐式方程。 当控制方程组中包含隐式微分代数方程或隐式微分方程式，归类为微分代数方程（DAE），其目标解为使得残差 ϵ\\epsilonϵ 值趋向于0。linear multistep常被用于求解此类问题。 例子：关于处理孔隙流动 小孔流动公式通常为： Q=CqA2ΔPρQ=C_qA\\sqrt{\\frac{2\\Delta P}{\\rho}} Q=Cq​Aρ2ΔP​​ 如果CqC_qCq​为定值，此时方程为显示代数方程 但如果Cq=f(∣Q∣)C_q = f(|Q|)Cq​=f(∣Q∣)，则该式为隐式代数方程需要迭代求解。此时求解目标为 ϵ=Q−f(∣Q∣)A2ΔPρ→0\\epsilon = Q-f(|Q|)A\\sqrt{\\frac{2\\Delta P}{\\rho}}\\rightarrow0 ϵ=Q−f(∣Q∣)Aρ2ΔP​​→0","categories":[{"name":"AMEsim","slug":"AMEsim","permalink":"http://yoursite.com/categories/AMEsim/"}],"tags":[{"name":"仿真","slug":"仿真","permalink":"http://yoursite.com/tags/%E4%BB%BF%E7%9C%9F/"}]},{"title":"TCL-视图","slug":"database/view","date":"2022-01-07T13:43:17.000Z","updated":"2022-03-17T14:24:17.527Z","comments":true,"path":"posts/database/view.html","link":"","permalink":"http://yoursite.com/posts/database/view.html","excerpt":"","text":"创建视图 将sql语句重用化，简化命令。 ​ 基本语法： 12345678create view ViewNameASselect querylist #将该部分查询结果作为视图from Table1 ConnectTypejoin Table2on Connection_requirementswhere conditions...;#查询语句 ​ 示例： 12345678910#查询姓名中包含a字符的员工名、部门名和工种信息create view infoasselect last_name,department_name,job_titlefrom employees ejoin departments d on e.department_id = d.department_idjoin jobs j on e.job_id = j.job_id;select * from info where last_name like '%a%'; 修改视图 123456789#方式一create or replace ViewNameas...#查询语句#方式二alter view as...#查询语句 删除视图 1drop view ViewName; 查看视图 1desc ViewName 更新视图数据 更新视图中的数据（非连接逻辑） 基本语法与普通表相同（表名替换为视图名） 注意： 以下视图(数据)不可更新(插入、修改、删除) 包含分组函数、distinct、group by 、having、union、union all的视图 常量视图、连接得到的视图、select 中包含子查询的视图 源自不可更新视图 ​ 2. 修改内容同步到源表","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"TCL-事务管理","slug":"database/TCL_","date":"2022-01-07T12:48:17.000Z","updated":"2022-03-17T14:12:00.559Z","comments":true,"path":"posts/database/TCL_.html","link":"","permalink":"http://yoursite.com/posts/database/TCL_.html","excerpt":"","text":"事务创建 创建事务 基本语法： 123456set autocommit = 0; #开始 事务start transaction; #可省略 SQL_Statements1; SQL_Statements2; ...commit; #结束 可使用回滚语句：rollback; 注意：在事务执行过程中的语句均改变表中数据，当使用commit结束时，结束事务并永久改变数据。使用roll back时，结束事务，放弃事务中对数据的改变，数据恢复事务开始前。 保存点 save point 可配合roll back 使用，结束事务并滚回到保存点位置 基本语法： 123456set autocommit = 0;start transaction; SQL_Statements1;savepoint SP_name; SQL_Statements2;rollback to SP_name; #回滚到保存点SP_name 事务并发 读取问题 当多个事务并发时，未设置隔离级别时可能出现以下问题： 脏读：读取了被 roll back 的数据 不可重复读：多次读取的结果不相同 幻读： 隔离级别 MySQL 支持4种隔离级别，默认为 repeatable read Oracle 支持2种（下表2、4），默认为read committed read uncommitted 允许读取未被提交的变更，所有错误均可能出现 read committed 允许读取已被提交的变更，可避免脏读 repeatable read 可保证多次读取字段的值相同，避免脏读、不可重复读 serializable 串行化，事务操作表时，禁止其他事务对该表操作，性能低 隔离级别设置命令： 1234#仅对当前连接有效set transaction isolation level ...#全局隔离级别set global transaction isolation level ...","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"DDL-约束介绍","slug":"database/DDL_constraint","date":"2022-01-07T08:00:17.000Z","updated":"2022-03-17T14:02:20.109Z","comments":true,"path":"posts/database/DDL_constraint.html","link":"","permalink":"http://yoursite.com/posts/database/DDL_constraint.html","excerpt":"","text":"约束用于限制表中数据，确保数据的可靠性 常见约束 类型 功能 not null 非空约束，保证数据不为null default 默认约束，在不输入时保证字段有默认值 primary key 主键，保证字段唯一性，且非空 unique 唯一，保证字段唯一性，但可以为null（null只能有一个） foreign key 外键，显示两表关系，保证字段值来自于主表关联列的值 check 检查，用于对字段值添加限制（mysql中不支持：无效但不报错） 添加约束 创建表时添加 基本语法： 12345create table TableName( column1 type1 constraint1, #此时constraint1、2为列约束 column2 type2 constraint2, constraint constName constType [references Table1(column3)] #此时constName为表约束); []内类容为使用foreign key时需要添加的关联列 列级约束，所有约束均可按照列级约束添加，但foreign key外键约束无效。 表级约束：除not null、default外的约束，均可作为表级约束。 示例： 12345678910111213141516171819202122232425262728293031create database students;use students;create table major( id int primary key, majorName varchar(20));#列级约束create table stuinfo( id int primary key, stuName varchar(20) not null, gender char(1) check(gender='男' or gender='女'),#mysql中无效 seat int unique, age int default 18, majorId int references major(id) #此处列级外键无效);#表级约束create table stuinfo( id int , stuName varchar(20) , gender char(1) , seat int , age int , majorId int, constraint pk primary key(id), constraint uq unique(seat), constraint ck check(gender='男' or gender='女'), constraint fk_stu_major foreign key(majorid) references major(id) ); 在修改过程中添加、删除 添加约束语法 123#约束添加alter table tablename modify column column1 type constraint1;#添加列级约束alter table tablename add constraint1(column); #添加表级约束 其中constraint1代表对应约束语句，具体格式见上文 删除约束语法 列级约束删除 12345#删除非空约束alter table TableName modify column CloumnName type null;#删除默认约束alter table TableName modify column CloumnName type; 表级约束删除 1alter table TableName drop constraint_Type constraint_Name； 由于 primary只有一个，因此可省略constraint_Name 特别注意 主键 同一个表中，unique可以有多个，但primary key只能有一个 可以将多个列组合成一个主键，其格式如 1constraint pk primary key(column1,column2) 外键 在从表中设置外键关系 从表列于主表关联列的类型要相同（或者兼容） 主表中的关联列必须是一个键（一般为primary key或者unique） 标识列 与约束类似，在创建表时添加： 12345678#设置自增长标识列create table TableName( ColumnName type unique auto_increment, ColumnName2 type2);#设置增长步长set auto_increment_increment = N; 在修改时添加、删除： 12345#添加标识列alter table tablename modify column column1 type constraint1 auto_increment;#删除标识列（即修改后不添加标识）alter table TableName modify column CloumnName type constraint1; 标识列必须为一个key(如primary,unique) 一个表中仅能有一个自增长列","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"DML-管理数据（记录）","slug":"database/DML_add","date":"2022-01-06T15:00:00.000Z","updated":"2022-03-17T13:55:55.713Z","comments":true,"path":"posts/database/DML_add.html","link":"","permalink":"http://yoursite.com/posts/database/DML_add.html","excerpt":"","text":"插入数据 使用insert into添加数据 123#方式一insert into TableName(column1,column2,...,columnN)values (value1,value2,...,valueN); 插入的值类型要与列的类型相同（或兼容） 在表中插入数据时，若没有指定某列，视为null；指定的列可以通过输入值输入null。若该列不允许null，则报错。额 输入过程中，指定列的顺序不要求与表中顺序一致。省略列名时，默认按照表中列的顺序依次输入。 示例： 12345678insert into beautyvalues (18,'张飞','男',null,'119',null,null);#包含子查询insert into beauty(name,phone) select boyName,'110' from boys where id&lt;3; 方式一支持输入多行、子查询 123#方式二(使用较少)insert into TableNameset column1=value1,...,columnN=valueN; 更改数据 单表修改 基本语法： 123update TableNameset column1=value1,...,columnN=valueNwhere condition_statement 示例： 1234set sql_safe_updates = 0; update beautyset phone = '13888888'where name like '张%' 当数据库处于安全保护模式下，修改数据将报错，可通过命令set sql_safe_updates = 0;关闭安全模式 多表修改 根据一个表的信息，修改另外一个表的数据 基本语法： 123456#99语法update TableName1inner join TableName2on connect_conditionset column1=value1,...,columnN=valueNwhere condition_statement 示例： 123456#将张无忌的cp的电话修改为114update boys boinner join beauty bon b.boyfriend_id = bo.idset b.phone = '114'where bo.boyName = '张无忌'; 删除数据 单表删除数据 基本语法： 123456#方式一delete from TableNamewhere condition_statement #无条件时，整表删除#方式二truncate TableName #整表删除 删除数据时整行删除 使用delete删除时，自增长列的值从断点开始；truncate删除时自增长列的值从1开始； 使用delete删除时有返回值，truncate删除，时无返回值。 使用delete删除时可以滚回，truncate删除，时不能滚回 示例： 12delete from beautywhere phone like '%9%'; 多表删除 根据一个表的信息，修改另外一个表的数据 基本语法： 123456#99语法delete TableNames #delete后应写需要删除数据的所有表的表名from TableName1inner join TableName2on connect_conditionwhere condition_statement 示例： 123456#删除黄晓明及其cp的信息delete b,bofrom beauty binner join boys boon b.boyfriend_id = bo.idwhere bo.boyName = '黄晓明';","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"DDL-数据类型","slug":"database/DDL_type","date":"2022-01-06T13:42:17.000Z","updated":"2022-03-17T14:01:20.526Z","comments":true,"path":"posts/database/DDL_type.html","link":"","permalink":"http://yoursite.com/posts/database/DDL_type.html","excerpt":"","text":"数值类型 整形 类型名称 字节大小 tinyint 1 smallint 2 mediumint 3 int 4 bigint 8 设置符号类型 默认为无符号，在数据类型后添加unsigned设置为无符号 1234create table TableName( num1 int,#有符号 num2 int unsigned# 无符号); 小数 浮点型 类型格式 字节大小 float(M,D) 4 double(M,D) 8 其中（M，D）可以省略。不省略时，M代表数字的总长度，D为小数部分长度。 定点型 类型格式 字节大小 decimal(M,D) M+2 当精度要求高时，推荐使用定点型 使用decimal时，M的默认值为10，D的默认值为0 字符型 短文本类型 类型格式 上限字符长度 char(M) M varchar(M) M 其中`char`类型为固定(存储空间)长度字符，`varchar`为可变长度字符。其中`char`效率更高 长字符 类型格式 一般用途 text 长文本 blob 较大的二进制字符串（如图片） 其他字符类型 类型格式 一般用途 enum 指定输入内容（只能输入单个） set 指定输入内容（可输入多个） 使用方法： 12345678#enum类型create table tablename( column1 enum('char1','char2','charN'));#set类型create table tablename( column1 set('char1','char2','charN')); 注意：列表内容均不区分大小写 日期型 类型格式 保存内容 year 仅年份 date 仅日期 time 仅时间 datetime 时间与日期（绝对） timestamp 时间与日期（根据时区等因素改变） datetime 8字节，年份范围1000-9999 timestamp 4字节，年份范围1970-2038","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"DDL-表管理","slug":"database/DDL_database","date":"2022-01-06T12:30:00.000Z","updated":"2022-03-17T13:59:14.510Z","comments":true,"path":"posts/database/DDL_database.html","link":"","permalink":"http://yoursite.com/posts/database/DDL_database.html","excerpt":"","text":"创建表 基本语法: 123456create table [if not exists] Table_Name( ColumnName1 Type[(length) constraint1 ] ColumnName2 Type[(length) constraint2 ] ColumnName3 Type[(length) constraint3 ] ...); []内语句为可选语句，()符号不可省略 注意：当Type为数据类型时，()内数字指显示长度，而不是字节长度 示例： 1234567create table book( id int, bName varchar(20), price double, authorId int, publishDate datetime); 修改表 修改列名 1alter table TableName change column columnName New_columnName Type; 修改列的类型或约束 1alter table TableName modify column columnName Type; 添加列、删除列 添加 1alter table TableName add column columnName Type; 删除 1alter table TableName drop column columnName; 修改表名 1alter table TableName rename to New_TableName; 复制表 复制表格结构 1create table Copy_Table like TableName; 创建一个结构与TableName相同的表Copy_Table 复制表格结构及数据 12create table Copy_Table select * from TableName; 通过子查询的方式获取TableName中的数据（可通过where等对表格数据处理后复制） 删除表 1drop table [if exists] TableName;","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-连接查询","slug":"database/MYSQL_link_query","date":"2021-12-28T07:25:00.000Z","updated":"2022-03-17T13:26:26.658Z","comments":true,"path":"posts/database/MYSQL_link_query.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_link_query.html","excerpt":"","text":"连接查询语法 以下介绍语法均为99版基本使用语法 123456##99版，支持所有类型select querylistfrom Table1 ConnectType join Table2 on Connection_requirementswhere conditions #可无 通常为各表取别名，以壁面歧义，增加可读性。 ConnectType 可选 内连inner ，左外left ，右外right，全外full ，交叉连接cross，缺省时为inner 内连接 等值连接 连接条件为等值判断，从两个表中查询数据合并为一个表。 示例： 12345678910111213141516#查询部门个数&gt;3的城市名和部门个数（分组、筛选）select city, count(*) from departments dinner join locations lon l.location_id = d.location_idgroup by d.location_idhaving count(*) &gt;3;#查询员工名、部门名、工种名，并按部门名降序（多表连接）select last_name,department_name,job_titlefrom employees einner join departments don e.department_id = e.department_idinner join jobs jon e.job_id = j.job_idorder by department_name desc; 非等值连接 除连接条件改变后，其余格式、用法与等值连接相同。 自连接 将一张表视为多张，在同一张表中查找信息进行匹配。 示例： 12345#查找上级select e.last_name,m.last_namefrom employees ejoin employees mon e.manager_id = m.employee_id 外部连接 用于查询部分数据仅在一个表中存的情况 区分主从表，若从表中存在匹配对象，显示匹配的值；若无，显示null 查询结果为主表中的所有记录：结果= 内连结果 + 【主表记录-null】 左/右外连接 左外连接left时，join左侧为主表；右外连接right时，join右侧为主表 123456use girls;select b.namefrom beauty bleft join boys boon bo.id = b.boyfriend_idwhere bo.id is null; 使用时先根据求取目标，确定主表 全外连接 相当于将两个表分别进行左外、右外连接后将结果合并。（MYSQL不支持full） 12345use girls;select b.* ,bo.*from beauty bfull outer join boys boon bo.id = b.boyfriend_id ; 交叉连接 相当于笛卡尔乘积 示例： 123456789#99交叉连接use girls;select b.name ,bo.boyNamefrom beauty bcross join boys bo;#等效笛卡尔select b.name ,bo.boyNamefrom beauty b, boys bo;","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-子查询","slug":"database/MYSQL_sub_query","date":"2021-12-28T07:25:00.000Z","updated":"2022-03-17T13:52:54.339Z","comments":true,"path":"posts/database/MYSQL_sub_query.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_sub_query.html","excerpt":"","text":"子查询基本语法 子查询可放于select，from，where，having，exists（相关子查询）后 子查询放于小括号内 子查询又可分为相关子查询与非相关子查询 相关子查询一般放置于where、having之后，需要从外部查询获取结果，其一般执行多次。 非相关子查询与外部查询相互独立，一般仅执行一次。 放置于where、having后 支持：标量子查询（单行子查询）、列子查询（多行子查询）、行子查询 此时子查询一般放在条件的右侧。 标量子查询使用单行操作符如&gt;,=；列子查询使用多行操作符in/not in any/some/all 标量子查询 示例： 123456789#查询最低工资大于50号部门最低工资的部门id及其最低工资select department_id, min(salary) from employeesgroup by department_idhaving min(salary)&gt; ( select min(salary) from employees where department_id =50); 注意：对分组后的数据进行筛选使用 having 列子查询 使用 in 修饰列子查询结果，返回符合列子查询结果的元素。 使用 any/some 修饰列子查询结果，将查询列表与列子查询结果依次对比，返回存在一次比较满足要求的结果。 使用 all 修饰列子查询结果，将查询列表与列子查询结果依次对比，返回所有比较均满足要求的结果。 示例： 12345678910111213141516171819202122232425262728293031323334 #返回其他工种中比job_id为'IT_PROG'部门任一工资低的员工的工号、姓名、jobid及工资 select employee_id,last_name,job_id,salary from employees where salary&lt; any( select salary from employees where job_id = 'IT_PROG' ) and job_id&lt;&gt; 'IT_PROG';#### **放置于`select`后**仅支持：标量子查询，一般为非相关子查询- 示例： ```sql #查询各部门信息及员工人数 #方式一 相关子查询 select d.*,( select count(*) from employees e where e.department_id =d.department_id) num from departments d; #方式二 连接+gorup by select d.*,count(e.department_id) num from departments d left outer join employees e on d.department_id = e.department_id group by d.department_id; 方式一中，子查询被执行多次，针对外部查询的每一个组元，都进行了一次子查询。 放置于from后 支持：表子查询 子查询一般为非相关子查询，结果作为一个虚拟表返回给外部查询。 示例 12345678910#查询各部门信息及员工人数#方式一,非相关子查询select d.* ,ifnull(c,0) numfrom departments dleft outer join ( select department_id,count(*) c from employees group by department_id) non n.department_id = d.department_id; 此时子查询必须要添加别名（虚拟表的表名）","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-分组函数及分组查询","slug":"database/MYSQL_groupfunction","date":"2021-12-21T09:25:00.000Z","updated":"2022-03-17T13:22:48.715Z","comments":true,"path":"posts/database/MYSQL_groupfunction.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_groupfunction.html","excerpt":"","text":"常见分组函数 可以与distinct配合使用 以下函数运算时均忽略null sum( column ) 求和，仅支持数值类型 avg( column ) 平均，仅支持数值类型 max( column ) 最大，支持数值、字符等可比较类型 min( column ) 最小，支持数值、字符等可比较类型 count( column ) 计数，仅计算非null单元，支持所有类型 注意：与分组函数一同查询的字段要求为group by (见下文)操作后的字段（保持表格规整） 示例： 123#利用 count、distinct 统计工种数目use myemployees;select count(distinct job_id) kindnum from employees; count() 函数 使用*可统计表中所有行的数目，如 123#统计 Tablename 表中所有有效行（不全为null）select count(*) from Tablename;select count(const) from Tablename;#相当于在非null行前添加'1'的元素，并计数 注意：count(*)的效率在一些引擎下效率比count(1)高，一般使用前者 分组查询 利用相同元素对数据进行分组管理，使用group by关键字实现。 基础语法 12345select column1,ground_func(column2)from tablenamewhere conditional_statement #可无group by expression #expression中理论包含column1order by column; #可无 注意：查询列表(select后的列)中的元素必须是分组函数或group by 后的字段 示例： 12345#查询各部门的，邮箱包含a字符的员工的平均工资select department_id , avg(salary)from employeeswhere email like '%a%'group by department_id; 分组查询后进行筛选，使用链接关键字having ： 12345#查询各人数大于2的部门人数select department_id,count(*)from employeesgroup by department_idhaving count(*)&gt;=2 ; group by 关键字后可以接用 函数、别名等。分组后支持排序。 多字段分组，只有多个字段同时相同，才会归并到同一个组。","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-单行函数","slug":"database/MYSQL_1Linefunction","date":"2021-12-20T15:00:00.000Z","updated":"2022-03-17T14:30:45.098Z","comments":true,"path":"posts/database/MYSQL_1Linefunction.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_1Linefunction.html","excerpt":"","text":"字符函数 length(str) 获取 str 的字节个数 concat(str1,str2,strn) 拼接字符 str1,str2,strn upper(str1)、lower(str1) 大小写转换 substr(str,num) 截取str字符长度从num开始的内容 instr(str,sub) 返回str中子串sub第一次出现的位置，若无该字串，返回0 trim( chars from str) 去掉str前后特定字符段chars，书写如 trim(str)时去掉空格 lpad(str,length,chars)【rpad】 使用char进行左【右】填充,使总长度为length。str超长时均从左侧开始截断 replace(str,sub,newsub) 使用 newsub 替换 str 中的 sub MYSQL 中，索引从 1 开始 substr()存在多个重载，如 substr(str,num,length)，截取Str从num开始length长度的字符 简单函数使用示例12345select rpad('Hellow_world',15,'!') As Game;#结果为 'Hellow_world!!!'select rpad('Hellow_world',6,'!') As Game;#结果为 'Hellow' 常见数学函数 round(num,n) 四舍五入保留n位，n缺省时为整数 ceil(num) 向上取整（>=num 的最小整数） floor(num) 向下取整 truncate(num,n) 截断num,保留n位小数 mode(num1,num2) 求余，与num1%num2相同 数学函数基本与其他语言类似，不再做介绍 日期函数 now() 返回当前时间 curdate()【curtime()】 获取当前日期【时间】 year(date)【month()】 获取数据date中的年份【月份】信息,同样有day,hour,minute等 str_to_date(str,format) 按照format中格式对str进行解析获取日期（默认格式） date_format(date,format) 按照format中格式，将格式转换为字符串 获取时间及日期基于当前系统时间 format格式除关键字符外部分可自行定义 简单示例 1234567891011121314#使用 str_to_date(str,format)#字符格式 年-日-月select str_to_date( '1998-25-2','%Y-%d-%c');#结果为 '1998-02-25'#使用 str_to_date(str,format)Use myemployees;select first_name,date_format(hiredate,'%m月/%d日 %Y年') As 入职日期from employeesorder by hiredate desc;#结果之一'Alberto', '12月/23日 2002年' 流程控制函数 if(a,b,c) 类似三元运算符 a?b:c; case switch语句用法 case 多重if 语句用法 - `case`使用语法： 123456789101112131415# switch用法case expressionwhen const_value1 then value1/statement1 [;]when const_value2 then value2/statement2 [;]...else value/statement [;]end [case]# 多重if用法case when condition1 then value1/statement1 [;]when condition2 then value2/statement2 [;]...else value/statement [;]end [case] 注意： 可搭配 select 作为查询表达式，此时when 后只能使用 值或表达式，不能使用语句。 case 可单独使用，进行流程控制（仅限在begin-end中）,此时语法需加上[]中内容，即 ;与end case switch相当于等值判断，if相当于区间判断在mySQL语法上区别在于cass后是否有表达，when后的判断为值还是条件判断 示例： 1234567891011121314151617#根据部门号，显示不同倍率的工资（switch用法）select salary,department_id,case department_idwhen 30 then salary*1.1when 40 then salary*1.2else salaryend As `new salary`from employees;#工资范围，区分等级（if 用法）select last_name,salary,case when salary&gt;=15000 then'A'when salary&gt;=10000 then 'B'else 'C'end As `Grade`from employees;","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-排序查询","slug":"database/MYSQL_sorting_query","date":"2021-12-20T14:29:17.000Z","updated":"2022-03-17T13:18:02.968Z","comments":true,"path":"posts/database/MYSQL_sorting_query.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_sorting_query.html","excerpt":"","text":"排序查询语法 基本语法格式如下，order by 一般放在查询的最后（除 limit） 12345678select querylistfrom tablenamewhere conditional statement #可无order by sortlist asc #降序为 desc；默认（省略时）asc 按表达式排序 1234# 根据年薪排序select *from employeesORDER BY salary*12*(1+IFNULL(commission_pct,0)); order by命令 初表达式外，同样支持使用别名、函数进行排序 多字段排序 123select *from employeesorder by salary asc, employee_id desc;","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-条件查询","slug":"database/MYSQL_condition_query","date":"2021-12-20T07:25:17.000Z","updated":"2022-03-17T13:16:12.862Z","comments":true,"path":"posts/database/MYSQL_condition_query.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_condition_query.html","excerpt":"","text":"条件查询语法 执行顺序: Tablename &gt;&gt; condition &gt;&gt;Querylist 123456Select QuerylistFrom TablenameWhere conditional statement; 按条件表达式筛选 条件运算符：&gt; &lt; = != &lt;&gt; &gt;= &lt;= 1234567#工资大于12000的员工姓，工号，工资select last_name,job_id,salaryfrom employeeswhere salary &gt; 12000; 按照模糊查询（复杂条件） 模糊查询关键字：like between and in is null is not null like关键字： 与SQL通配符一同使用，如 %(任意多个) _(任意单个)，_与% 的转义符为\\ 1234#寻找含有a的姓名select *from employeeswhere last_name like '%a%'; 可通过 escape指定转义符如： last_name LIKE '_$_%' escape '$'; between value1 and value2 关键字： 等价于department_id&gt;=value1 OR department_id&lt;=value2 1234567#部门编号在90-110，select *fromemployeeswheredepartment_id between 90 and 110 ; 注意：其中value2&gt;value1，包含边界值。 in 关键字 用于判断 列表中是否存在符合 in 后关键字列表的元素。 1234567#读取对应工种名单select *fromemployeeswhere job_id IN ('IT_PROG','AD_VP'); 注意：不能使用通配符，IN列表类型相同/兼容。 Is null 与Is not null 由于 =不能用于 null的比较，故使用此关键字。 安全等于：&lt;=&gt;可以用于null的比较，通常不使用。 按逻辑表达式筛选 推荐逻辑关键字：and or not 1234567#部门编号不在90-110，或工资高于15000select *from employeeswhere department_id&gt;110 OR department_id&lt;90 OR salary&gt;15000;","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-基础查询","slug":"database/MYSQL_basic_query","date":"2021-12-20T03:49:17.000Z","updated":"2022-03-17T13:16:21.800Z","comments":true,"path":"posts/database/MYSQL_basic_query.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_basic_query.html","excerpt":"","text":"基础查询语法 Querylist可以是表中的字段、常量值、表达式、函数。可以是多个字段，以逗号相隔。 查询的结果为虚拟表格（不影响表格内容） 12Select QuerylistFrom Tablename; #非必要行，指定查询位置 查询字段 123456#单个字段SELECT last_name FROM employees;#多个字段SELECT last_name,salary,email FROM employees;#所有字段SELECT * FROM employees; 注意：1. 查询多个查询表时，按照查询序输出。使用*时默认按表格顺序； 必要时通过添加着重符号 ` 区分关键字与字段名，增加可读性 查询常量/表达式/函数 123456789#查询值SELECT 100;SELECT 'john';#查询表达式SELECT 100%98;#查询函数SELECT version(); 注意：1. 字符都默认为字符串，使用单引号 计算表达式后查询 查询函数相当于获取函数返回值 去除重复项目 利用 distinct关键字去除重复项 1select distinct department_id from employees; 字符拼接 SQL中，+号只作算数运算符，其规则如下 运算对象存在字符类型，将其转化为数字：若成功，算数加法；若失败，字符转化为0。 运算对象存在null，运算结果为null 采用concat函数链接，详见单行函数 123#合并select concat(last_name,first_name) AS `name`from employees; 查询列表别名 便于理解（给表达式查询命名） 重名字段区分。 123456#单个字段SELECT 100%98 As result#多个字段SELECT last_name AS 姓,first_name AS 名FROM employees; AS 可省略，用空格代替；别名存在分隔(如空格)时，采用“ ”包括壁面歧义","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"SQL-常用命令","slug":"database/MYSQL_command","date":"2021-12-20T01:20:17.000Z","updated":"2022-03-17T13:16:43.076Z","comments":true,"path":"posts/database/MYSQL_command.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_command.html","excerpt":"","text":"常用命令 1、查看 &amp; 打开 mysql→\\rightarrow→库→\\rightarrow→表→\\rightarrow→数据，使用desc、show &amp; use 进行查看与访问. 初始默认4个数据库information_schema、mysql、performance_schema、test。前三个不可修改 语法 查看所有数据库 show databases； 查看当前数据库 select datbase(); 查看当前库所有表 show tables; 查看指定库所有表 show tables from DatabaseName; 查看表结构 desc TableName; 打开指定数据库 use DatabaseName 语句末尾需要加分号 ; 命令语句不区分大小写 注释：单行注释 #注释，-- 注释（空格不可去），多行注释\\*注释*\\ 2、创建&amp;删除 语法 创建表 12345creat table TableNanme( RowName1 type， RowName2 type, ...); 删除表","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"MYSQL安装","slug":"database/MYSQL_start","date":"2021-12-19T01:09:17.000Z","updated":"2022-03-17T09:55:11.254Z","comments":true,"path":"posts/database/MYSQL_start.html","link":"","permalink":"http://yoursite.com/posts/database/MYSQL_start.html","excerpt":"","text":"软件安装 官网：https://www.mysql.com/ ，选择DownLoads &gt;&gt; Community社区版 &gt;&gt; Installer 打开安装包，选择自定义安装(Custom)，添加server，点击Options可更改安装路径 配置：选用开发机，默认端口（3306），next。输入root用户密码，设置服务名。 环境变量：复制bin路径，如C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin 右击计算机 &gt;&gt; 属性 &gt;&gt;高级系统设置 &gt;&gt;高级&gt;&gt;环境变量&gt;&gt;新建，粘贴 安装图形化界面 通过官网安装 / 通过Installer&gt;&gt;add&gt;&gt;workbench 安装 一般会自动识别账户，若没有点击+号自行设置 启动/停止服务 通过电脑-&gt;管理-&gt;服务和管理-&gt;服务-&gt;启动MySQL服务 通过命令行启动服务 12&gt; net start mysqlname&gt; net stop mysqlname 登录/退出服务端 通过客户端-&gt;输入密码 通过命令行：mysql -h 主机名 -P 端口号 -u 用户 -p 密码 12&gt; mysql -h localhost -P 3306 -u root - p&gt; passwords","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"Start-数据库系统（目录）","slug":"database/database_index","date":"2021-12-18T01:09:17.000Z","updated":"2022-03-17T14:27:24.359Z","comments":true,"path":"posts/database/database_index.html","link":"","permalink":"http://yoursite.com/posts/database/database_index.html","excerpt":"","text":"软件（MYSQL） 安装、启动及登录 —— MySQL安装 图形化界面使用 常见指令 SQL语言 —DQL查询语法 (Data Query Language) 基础查询——&gt;详情 列表查询 列表别名 使用语法： 12Select QuerylistFrom Tablename; #非必要行，指定查询位置 条件查询——&gt;详情 条件表达式 逻辑表达式 使用语法： 123456Select QuerylistFrom TablenameWhere conditional statement; 排序查询——&gt;详情 使用语法： 12345678select querylistfrom tablenamewhere conditional statement #可无order by sortlist asc; #降序为 desc；默认（省略时）asc 常见函数 单行函数——&gt;函数介绍 用作数据处理，如 concat()、length()、ifnull()，输入单值，输出单值。 字符函数 数学函数 日期函数 流程控制函数 分组函数及查询——&gt;函数介绍 又称为统计函数，用于数据统计，输入一组函数。 分组函数 分组查询 使用语法： 12select function(value) from Tablename #此命令可无 链接查询——&gt;具体说明（99版） 内连接（inner） 等值连接 非等值连接 自连接 外连接 左外连接（left） 右外连接（right） 全外连接（full） 交叉连接（cross） 使用语法： 1234567891011121314##92版，仅支持内连接select Table1.column1 ,Table2.column2from Table1, Table2where Connection_requirements #标明连接条件，否则出现笛卡尔连接（mXn行）And conditions #使用AND追加筛选条件，多表连接条件，可无group by cloumn3 #可无order by column4 desc#可无##99版，支持所有类型select querylistfrom Table1 ConnectType#ConnectType 为连接类型默认inner，见上文括号内容join Table2on Connection_requirementswhere conditions #可无 有92及99两个版本的连接版本语法，推荐使用99版本 Connection_requirements 可为等值、非等值判断，对应不同类型连接 子查询——&gt;具体说明（99版） 标量子查询（1X1） 列子查询（nX1） 行子查询（1Xn） 表子查询（nXm） 使用()将查询放于select，from，where，having，exists之后，作为子查询 分页查询 可用作分段提交sql查询请求 使用语法： 12345678910select querylistfrom tablenamewhere conditional statement #可无order by sortlist asc #可无limit offset,size; #offset为开始条目（初始条目为0），size为条目数 联合查询 用于合并多条查询语句的查询结果（可用作合并来自不同表的查询结果，但理论上要求有一定联系） 使用语法： 123select * from talbe1 where conditiona statement1union #使用 union all时可包含重复项select * from talbe2 where conditiona statement2; 联合查询要求多个查询语句的查询列数相同。 union 默认去重，union all时可包含重复项 以上所提到的关键字执行顺序如下： from→ join→on→where→group by→分组函数→ having→select→distinct→order by→limit 执行过程中生成虚拟表，并对虚拟表进行操作更新虚拟表（连接、分组等），直到select才从虚拟表中提取查询列 DML 数据管理 插入 insert into 修改 update 删除 delete 使用语法：详情 DDL 数据定义 通常在创建数据库、表格时，一般情况下会先对现有表进行删除（除非需要其中数据），再创建表 通常语法： 12drop database if exists Database_Name ;#或者TableNamecreat database Database_Name;#或Table创建语句 库管理语言 创建库 1create database [if not exists] DataBase_Name; []内语句为可选语句，通过 if not exists 判断可增加容错性 修改库 修改字符集语法： 1alter database books character set gbk; 注意：通常情况下不修改库的信息。 删除库 1drop database [if exists] DataBase_Name; 表管理语言——&gt;详情 创建表 修改表 修改列名（change） 修改列类型、约束（modify） ——&gt; 类型说明 ——&gt;约束说明(含标识列) 添加、删除列（add，drop） 修改表名（rename to） 复制表 删除表 TCL 事务管理 事务：一个或一组sql语句组成的一个执行单元。 存储引擎：用不同的技术存储数据库中的数据与文件（或内存）。 myisam，memory等引擎不支持事务 事务相关操作——&gt;详情 事务创建 保存点 save point 事务并发 引发问题：脏读、不可重复读、幻读 隔离级别：read uncommitted read committed repeatable read serializable 基本语法： 123456set autocommit = 0; #开始 事务start transaction; #可省略 SQL_Statements1; SQL_Statements2; ...commit; #结束 可使用回滚语句：rollback; 事务的基本属性（ACDI） 原子性 Atomicity：事务内容不可分割 一致性 Consistency：事务执行前后数据状态一致 隔离性 Isolation：事务的执行不被其他事务干扰（根据隔离级别） 持久性 Durability：事务一旦提交，永久改变库中数据 视图 可看作虚拟表，与普通表用法相同，具有临时性。仅保存sql逻辑，不保存查询结果。 视图操作——&gt; 详情 创建 修改 删除 更新（视图数据） 变量 系统变量：由系统提供，属于服务器层面 使用@@ 标识系统变量 全局变量 global 基本语法： 12345678#查看系统变量Show global variables; #global为全局show global variables like '%char%'; #查找一定变量select @@global.VariableName; #查看特定全局变量#给变量赋值set @@global.VariableName= value1; 给全局变量赋值对所有会话（连接）有效，但不跨重启 会话变量 session 基本语法： 123456789#查看系统变量Show [session] variables; #[session]为会话，可省略show [session] variables like '%char%'; select @@[session.]VariableName; #查看特定变量#给变量赋值set @@VariableName= value1;set session VariableName= value1; 自定义变量 用户变量：作用于当前会话 使用语法 12345678910#声明(也可用作赋值)set @VariableName := value1;select @VariableName := value1;#赋值select column1 into @VariableNamefrom TableName;#查看、使用select @VariableName; 使用 @ 符号区分用户变量和列名，使用:= 对变量赋值 select 为查询部分，在后续使用查询语法。 示例： 1234567#用户变量set @count := 1;select count(*) into @countfrom employees;select @count; 局部变量：仅作用于其定义的begin end中 使用语法： 123456789101112#声明declare VariableName type [default value1];#赋值set VariableName := value1;select @VariableName := value1;select column1 into VariableNamefrom TableName;#查看、使用select VariableName; 通常不需要使用@ []中为非必要语句。局部变量必须声明类型，且需在begin end 域内第一句。 存储过程与函数 存储过程：一组预先编译好的sql语句集合（批量处理语句） 与函数/方法类似，可简化操作、提高效率（较少编译次数及连接次数） 创建过程 参数列表 参数模式 [mode] in：该参数可作为输入 out：该参数可作为输出 inout：支持输入和返回 参数名 [paramenter] 参数类型 [type] 123456delimiter $create procedure PName(mode paramenter type)begin SQL_statements; ...end $ 存储过程中每条语句结尾需要添加 ; 可通过 delimiter 重新设置存储过程的结束标识 调用过程 1call PName(parameters); 示例： in 模式 1234567891011use girls;delimiter $ #定义结束标志create procedure myp2(in beautyName varchar(20))begin select bo.* from boys bo right join beauty b on bo.id = b.boyfriend_id where beautyName = b.name ;end $call myp2('赵敏'); out 模式 12345678910create procedure myp3(in beautyName varchar(20),out boyName varchar(20))begin select bo.boyName into boyName from boys bo inner join beauty b on bo.id = b.boyfriend_id where beautyName = b.name;end $call myp3('小昭',@bName);#调用select @bName; 删除过程 1drop procedure PName;#一次只能删除一个 查看过程 1show create procedure PName; 创建函数 函数与存储过程相似，但有且仅有一个返回值 123456create function funcName(paramenter type) returns return_type #声明begin SQL_statements; ... return end 错误1418：log_bin_trust_function_creators 变量为0时，用户不得创建或修改存储函数，将该变量设置为1即可： set global log_bin_trust_function_creators=TRUE; 删除函数 1drop function funcName;#一次只能删除一个 查看函数 1show create function funcName; 流程控制结构 顺序结构 分支结构——&gt;函数介绍（流程控制函数） if(a,b,c) if 结构 语法： 12345if condition1 then value1/statement1 ;else if condition2 then value1/statement2;...else value1/statement2;end if; case 结构 示例： 1234567891011121314#建立存储过程，按成绩显示等级delimiter $create procedure grade(in score int)begincase when score between 90 and 100 then select 'A'; when score between 80 and 90 then select 'B'; when score between 60 and 80 then select 'c'; else select 'D';end case;end $delimiter ;call grade(89); 循环结构 while 结构 1234[tap:] while Condition1 do sql_statements; ...end while [tap]; loop 结构 1234[tap:] loop sql_statements; ...end loop [tap]; repeat 结构 12345[tap:] repeat sql_statements; ...until end_Conditionend repeat [tap]; 退出语句 iterate ：开始下次循环【countinue】 leave：结束当前所在循环【break】","categories":[{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"}]},{"title":"健身计划（一）","slug":"sport/健身","date":"2021-08-14T09:21:21.000Z","updated":"2022-03-17T10:01:46.839Z","comments":false,"path":"posts/sport/健身.html","link":"","permalink":"http://yoursite.com/posts/sport/%E5%81%A5%E8%BA%AB.html","excerpt":"","text":"训练计划 训练时间表 周一 周二 周三 周四 周五 周六 周日 胸背 腿臂 胸背 腿臂 训练内容 根据推荐，但是因为一些动作个人觉得容易受伤，规避掉这些动作后安排了训练计划。 RM：最大重复次数 高稳定复合：6-8RM 杠铃深蹲、杠铃卧推 常规复合：8-12RM 器械动作、哑铃动作、坐姿划船 单关节动作：13-15RM 侧平举、面拉 胸 哑铃卧推 3X8 斜上推举 4X12 背 高位下拉 4X12 坐姿划船 4X12 单臂划船 3X~（选做） 腿 深蹲 4X8 器械腿弯举 4X8 臂 侧平举 4X！ 面拉 4X！ 训练阶段 动作学习阶段 通过小重量多次数的训练熟悉动作，保持在最后一组完成后接近极限 重量控制阶段 从学习阶段缓慢过度，每次训练增加一些重量，指导做不动 容量增加阶段 复合动作根据重量控制时的训练容量，重新计算组次。掌握后 动作学习 重量控制 容量增加 2周 4周 ∞\\infin∞ X20 X10~12 x8~12 注意事项 热身 预热5-10分钟 上肢热身 拉伸胸小肌，采用弹振式动态拉伸：压三秒，松1秒，左右各5次 伟大拉伸，手称腿5s，抬手5s，两边各1次。 绕肩，前后环绕10次 平板30s两组 下肢热身 伟大拉伸， 蛙趴 小腿拉伸 侧蹲，左右各10次 平板 激活目标肌群热身组 背部 运动时先收缩夹紧肩胛骨 控制手肘位置 不越过肩膀，与地面保持垂直","categories":[{"name":"Sport","slug":"Sport","permalink":"http://yoursite.com/categories/Sport/"}],"tags":[{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/%E8%BF%90%E5%8A%A8/"}]},{"title":"读书笔记——《穷富爸爸》","slug":"MutualFunds/穷富爸爸","date":"2021-07-15T04:27:32.000Z","updated":"2022-03-29T07:21:14.610Z","comments":true,"path":"posts/MutualFunds/穷富爸爸.html","link":"","permalink":"http://yoursite.com/posts/MutualFunds/%E7%A9%B7%E5%AF%8C%E7%88%B8%E7%88%B8.html","excerpt":"","text":"声明：我个人是秉承着改变对资产的态度以及认识投资的想法进行阅读的。因此以下笔记包含个人看法，并非完全书中观点。 关于财富 理解资产 资产：预期会带来经济利益的资源（把钱放到口袋里的东西） 负债：预期会导致经济利益流出的现时义务（把钱从口袋里取走的东西） 书中提到通过不同人群的现金流向分析对到手的钱的处理方式，总结起来可以得到下面的一个流向图，分别描述了购入资产增值的收入和购入负债陷入财政陷阱的过程。 对现金流的不理解可能会造成财务困境，重要的是明白自己选择支出的方式，这诞生了最初的”理财态度“ 如何花掉挣的钱 如何防止他人夺走 能多长时间拥有这笔钱 如何利用钱产生价值 房子并非时刻是最优投资，在某种角度下，房屋可能是负债而非资产 失去资产增值的机会 由于支付房屋而来的长期开支（诸如贷款） 然而就目前国内房价增值速度来开，购入房屋更想是使用杠杆进行投资 引用巴安克敏斯顿·菲莱的话语 ”财富是支撑一个人活多长时间的能力“（停止工作的情况下） 我们可以认为，财富是通过资产产生的收入的现金流与支出的现金流进行比较而定的，进而有以下的几点认识： 流入资产的项的资金越多，资产增值越快 把支出（包括负载产生的部分）控制在资产所能够产生的现金流之下，财富得到积累 尽量避免购入表面为资产的负债 关于事业 关注事业，意思是构筑自己的资产项目 事业与工作是有区别的，作为雇员进行生产时，要有意识地建立自己地资产项目，其中包括脱手盈利业务、股票等。 购入奢侈消费品前，应更优先建立资产。使用由资产产生的额外价值购入消费品，而非因欲望而购入表面资产的负债（比如贷款/收入抽成买豪车） 注重财商 税率是不可忽视的 不少一部分人会通过拥有一个自己的资产公司进而避免掉一些税费（公司收入税率比个人收入税率低）。 可以这样做的前提由很多，包括自身本身的知识储备（或通过雇佣专业人员获得），当通晓金融运转的原理及相关的法律知识后，能更加清楚地判断自己的行为，进而充分利用权利实现自己的事业。 关于财商 财务智商（知识） 万丈高楼平地起，我们为将机会转变为财富，需要具备一定的财务智商，这使得我们需要对以下几个方面进行学习 会计知识 投资知识 市场知识 法律知识 思维的转变 习惯变化，改变对投资的态度（接受风险） 认识自己的行为，通过知识降低风险，避免赌博心理 不要为了金钱而工作，工作是为了学习新知识 不要畏惧学习新东西 抓住机会 一位优秀的投资者需要有组合机会的能力，为此要求的能力有以下几种 寻找常人忽视的机会 融资能力 管理知识 现金流管理 人事管理 个人时间管理 *通过学习销售知识提高与人交往的能力 * 如果不能很好地去培养此类能力，最好成为普通投资者，进行常规投资（股票基金），以避免不必要的风险 关于困难 在投资/财富积累期间存在一定的障碍，克服这些障碍需要一定的努力。下面给出主要的一些障碍和克服的小方法和提示。 实际上除了在投资方面，在处理其他的事情上，这些障碍依旧存在，且影响极大。 恐惧心理 人们总是害怕失败（失去金钱），这是正常的，但是需要正确的处理这种恐惧，讨厌失败和害怕失败之间有巨大的差距。减轻恐惧可以从下面的建议入手。 提早积累财富，通过风险较低的基金/股票投资的时间复利在退休前得到较多的财富积累。 傲慢自负 不要通过夸夸其谈掩盖自己的无知，未知的部分往往使人损失金钱。 承认知识上的缺失，进行学习或者雇佣/请教对应的专家 愤世嫉俗 避免抱怨现实，学会分析现实 将注意力放在麻烦解决后的收益而非麻烦本身 懒惰 人们通常借由“我很忙”这类借口去逃避一些不想要面对的事情，然而实际上并非很忙，仅仅是懒惰 适当提高自己的欲望说服自己行动 习惯 将自己放置于安稳状态的习惯可能会让人们失去动力、丧失抓住机会的筹码 避免背上大额负债 改变支付习惯，优先投资于自己（包括资产投资、学习） 当资金紧缺时主动承受压力，暂时不要动用储蓄和投资，通过压力刺激自己的思维、能力提高（因人而异） 关于实践 作出自己地选择，并为之努力。进行阅读及学习，投资于头脑这一个最重要的资产 掌握一种模式，然后学习新的模式，具备快速学习的能力 优先投资在自己的事业上 给予专业人士更优的报酬以换取好的建议 时刻关注自己投资的回报（回收周期） 购买奢侈品时应该使用资产收益而非工作收入","categories":[{"name":"课外阅读","slug":"课外阅读","permalink":"http://yoursite.com/categories/%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/%E9%87%91%E8%9E%8D/"}]},{"title":"Matlab FIR及IIR 数字滤波器  (一)","slug":"DSP/digital_filter_1","date":"2020-11-06T10:30:20.000Z","updated":"2022-03-29T07:19:55.972Z","comments":true,"path":"posts/DSP/digital_filter_1.html","link":"","permalink":"http://yoursite.com/posts/DSP/digital_filter_1.html","excerpt":"","text":"前言: 本文为本人在学习华科&quot;数字信号分析理论与实践&quot;课程所做的记录, 由于本人能力有限,在实现方法等各方面存在问题,欢迎交流指出. 本文将介绍实现最简单的FIR数字滤波器(fir1函数) ,以及附带的滤波函数(filter) FIR 滤波器 原理分析 设计一个滤波器相当于设计一个系统,通过它的传递函数屏蔽掉不需要的输入信号,保留目标信息. ​ FIR(Finite Impulse Response)滤波器,即&quot;有限长单位冲激响应滤波器&quot;,其脉冲响应是有限的持续时间，并在有限的时间内稳定为零。 其傅立叶系数h(n)实际上就是数字滤波器的冲击响应. h(k)=a(k),k=0,1,2,...,Nh(k)=a(k),k=0,1,2,...,N h(k)=a(k),k=0,1,2,...,N 其单边Z变换为 H(z)=∑k=0NakZ−kH(z)=\\sum^N_{k=0}{a_kZ^{-k}} H(z)=k=0∑N​ak​Z−k 低通滤波器 理想的滤波器频率响应方程为1 Hd(ω)={1∣ω∣≤ωc0ω&lt;∣ω∣&lt;πH_d(\\omega)=\\begin{cases} 1&amp; |\\omega|\\leq \\omega_c \\\\ 0&amp; \\omega&lt;|\\omega|&lt;\\pi \\end{cases} Hd​(ω)={10​∣ω∣≤ωc​ω&lt;∣ω∣&lt;π​ hd(k)=ωcpisin(ωck)ωck;k=0;±1,±2,..,∞h_d(k)=\\frac{\\omega_c}{pi}\\frac{sin(\\omega_ck)}{\\omega_ck};k=0;\\pm1,\\pm2,..,\\infty hd​(k)=piωc​​ωc​ksin(ωc​k)​;k=0;±1,±2,..,∞ 对系数进行归一化, 即 a0=v1=fc/12fsan=sin(nπv1)nπ; n=0;±1,±2,..,∞\\begin{aligned} a_0 &amp;= v_1 = {f_c}/{\\frac{1}{2}f_s}\\\\ a_n &amp;= \\frac{sin(n \\pi v_1)}{n \\pi};\\ n=0;\\pm1,\\pm2,..,\\infty \\end{aligned} a0​an​​=v1​=fc​/21​fs​=nπsin(nπv1​)​; n=0;±1,±2,..,∞​ 高通滤波器 理想的滤波器频率响应方程, 及系数计算 Hd(ω)={1∣ω∣≥ωc0othera0=1−v1an=−sin(nπv1)nπ; n=0;±1,±2,..,∞\\begin{aligned} &amp;H_d(\\omega)=\\begin{cases} 1&amp; |\\omega|\\geq \\omega_c \\\\ 0&amp; other \\end{cases}\\\\ a_0 &amp;= 1-v_1 \\\\ a_n &amp;= -\\frac{sin(n \\pi v_1)} {n \\pi};\\ n=0;\\pm1,\\pm2,..,\\infty \\end{aligned} a0​an​​Hd​(ω)={10​∣ω∣≥ωc​other​=1−v1​=−nπsin(nπv1​)​; n=0;±1,±2,..,∞​ 带通系数 理想的滤波器频率响应方程,及系数计算 Hd(ω)={1ω≤∣ω∣≤π0othera0=v2−v1an=sin(nπv2)−sin(nπv1)nπ; n=0;±1,±2,..,∞\\begin{aligned} &amp;H_d(\\omega)=\\begin{cases} 1&amp; \\omega\\leq|\\omega|\\leq\\pi \\\\ 0&amp;other \\end{cases}\\\\ a_0 &amp;= v_2-v_1 \\\\ a_n &amp;= \\frac{sin(n \\pi v_2)-sin(n \\pi v_1)}{n \\pi};\\ n=0;\\pm1,\\pm2,..,\\infty \\end{aligned} a0​an​​Hd​(ω)={10​ω≤∣ω∣≤πother​=v2​−v1​=nπsin(nπv2​)−sin(nπv1​)​; n=0;±1,±2,..,∞​ 由于h(k)可能是无限长序列，是物理不可实现的,为此要寻找一个h(n)，在相应的误差准则下最近逼近h(k)。 带阻系数 理想的滤波器频率响应方程,及系数计算 Hd(ω)={0ω≤∣ω∣≤π1othera0=1−(v2−v1)an=−sin(nπv2)−sin(nπv1)nπ; n=0;±1,±2,..,∞\\begin{aligned} &amp;H_d(\\omega)=\\begin{cases} 0&amp; \\omega\\leq|\\omega|\\leq\\pi \\\\ 1&amp;other \\end{cases}\\\\ a_0 &amp;= 1-(v_2-v_1) \\\\ a_n &amp;= -\\frac{sin(n \\pi v_2)-sin(n \\pi v_1)}{n \\pi};\\ n=0;\\pm1,\\pm2,..,\\infty \\end{aligned} a0​an​​Hd​(ω)={01​ω≤∣ω∣≤πother​=1−(v2​−v1​)=−nπsin(nπv2​)−sin(nπv1​)​; n=0;±1,±2,..,∞​ 系数处理(窗函数法) h(k)h(k)h(k) 可能是无限长序列，是物理不可实现的,为此要寻找一个 h(n)h(n)h(n)，在相应的误差准则下最近逼近h(k)h(k)h(k)。 直接截取前n各系数, 故需要通过窗函数方法对系数进行平滑处理, 减小由于截断带来的跳动. h(n)=w(n)⋅a(n)h(n)=w(n)·a(n) h(n)=w(n)⋅a(n) 本实现中默认使用汉宁(Hamming)窗函数对系数进行平滑处理. 程序实现 首先进行进行输入参数的判断 必须要输入的参数有采样点数目Np ,相对截止频率 v .其中v可以为二维数组 可选参数有 加窗类型 (通过指针p1保存) , 滤波器类型(通过指针p2保存) 123456789101112131415161718192021222324252627282930function b = firl_fun(Np,v,varargin)% % 使用方法 % % firl_fun(Np,v) N为取样点数目，低通滤波器，截止频率v*fs% % firl_fun(Np,v,@wintype) 加窗类型wintype,如 @hamming% % firl_fun(Np,v,type) 滤波方式type可选'high'高通,'low'低通% % firl_fun(Np,v,@wintype,type)% % firl_fun(Np,[v1,v2]) % % firl_fun(Np,[v1,v2],type) 可选'bandpass'带通,'bandstop'带阻% % firl_fun(Np,[v1,v2],@wintype,type)N = floor(Np/2);narginchk(2,4);%检查输入参数个数p1 = @hamming; %p1指向窗函数(默认汉宁)p2 = 'low'; %p2指向滤波类型（默认低通）%判断滤波类型switch nargin %只有3个参数的判断， case 3 if isa(varargin&#123;1&#125;,'function_handle') p1 = varargin&#123;1&#125;; else p2 = varargin&#123;1&#125;; end %4参数读入 case 4 p1 = varargin&#123;1&#125;; p2 = varargin&#123;2&#125;; end 然后根据所选类型进行原理中的系数计算, 完成滤波器设计. 12345678910111213141516171819202122232425262728293031323334k=1; %判断滤波器类型switch p2 case 'low' %低通 for i=-N:N f=i*pi; h(k)=sin(v(1)*f)/f; %计算响应函数 k=k+1; end h(N+1)=v(1); case 'high' %高通 for i=-N:N f=i*pi; h(k)=-sin(v(1)*f)/f; k=k+1; end h(N+1)=1-v(1); case 'bandpass' %带通 for i=-N:N f=i*pi; h(k)=(sin(v(2)*f)-sin(v(1)*f))/f; k=k+1; end h(N+1)=v(2)-v(1); case 'bandstop' %带通阻止 for i=-N:N f=i*pi; h(k)=-(sin(v(2)*f)-sin(v(1)*f))/f; k=k+1; end h(N+1)=1-(v(2)-v(1));endb = h.*p1(2*N+1)';% -N:N的长度为2N+1end 实际效果 低通、高通 带通、带阻 #### 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869clear;%设计的样本 %原信号Fs = 2048;dt=1.0/Fs;T =1; N=T/dt;t=[0:N-1]/N;x1 =sin(2*pi*50*t)+sin(2*pi*300*t) +sin(2*pi*500*t);subplot(3,2,1); plot(t,x1); axis([0, 0.1, -2,2]);title(\"原信号时域\"); P=fft(x1,N);Pyy =2*sqrt(P.* conj(P))/N;f=linspace(0,Fs/2,N/2);subplot(3,2,2);plot(f,Pyy(1:N/2));title(\"原信号频域\");%选择滤波器type = 4;%--------------------------系统自带fir1 和filterswitch type case 1 b = fir1(48,0.1); case 2 b = fir1(48,0.1,'high'); case 3 b = fir1(48,[0.1,0.3]); case 4 b = fir1(48,[0.1,0.3],'stop');endx2= filter(b,1,x1);%------------------------自己写的fir1_fun 和 filter_funswitch type case 1 b2 = firl_fun(48,0.1,@hamming); case 2 b2 = firl_fun(48,0.1,@hamming,'high'); case 3 b2 = firl_fun(48,[0.1,0.3],@hamming,'bandpass'); case 4 b2 = firl_fun(48,[0.1,0.3],@hamming,'bandstop');endx3= filter_fun(b2,1,x1);%--------------------------（自带滤波器频域图）subplot(3,2,3);[h,w] = freqz(b,1,512);plot(w/pi,abs(h),'linewidth',1)title(\"Matlab的滤波器频域图\"); %--------------------------（自带滤波器处理后）subplot(3,2,5);plot(t,x2);axis([0, 0.1, -2,2]);title(\"Matlab的滤波器处理后\"); %--------------------------（编写的滤波器频域图）subplot(3,2,4);[h,w] = freqz(b2,1,512);plot(w/pi,abs(h),'linewidth',1)title(\"自写的滤波器频域图\"); %--------------------------（编写的滤波器处理后）subplot(3,2,6);plot(t,x3);axis([0, 0.1, -2,2]);title(\"自写的滤波器处理后\"); 滤波器的实现 原理分析 按照Matlab的原理解释 那实现就很简单了 12345678910111213141516171819202122232425262728293031323334function y= filter_fun(b,a,f)%这个滤波实际上就是把现有数据当作输入，滤波公式当作系统传递函数%FIR时，利用卷积求出系统响应就好了，所及这个就相当于一个卷积算法。%FII时，利用就根据差分方程计算出来。n = length(b);m = length(f);na = length(a)-1;%分母最高阶次数S = zeros(1,m);%卷积结果存放%t=1:n-1 时为开头过度段，缺位补零相乘，求和时相当于没有该项%t=n:m-1 时，按照卷积公式滑动求和%t=m:m+n-1 时，时为尾部过度段，与 t=2:n 类似。for t=1:n-1 S(t) = sum(f(1:t).*fliplr(b(1:t))) ; if na &gt;2 if t &gt; na S(t) = S(t) - sum( fliplr(a(2:na+1)).*S(t-1:t-na)); else S(t) = S(t) - sum( fliplr(a(2:t)).*S(1:t-1)); end endendfor t = n:m-1 S(t) = sum(f(t-n+1:t).*fliplr(b(1:n))); if na &gt;2 if t &gt; na S(t) = S(t) - sum( fliplr(a(2:na+1)).*S(t-na:t-1)); else S(t) = S(t) - sum( fliplr(a(2:t)).*S(1:t-1)); end end endy = S;","categories":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Matlab 自相关分析实现","slug":"DSP/correlation_analysis_1","date":"2020-11-06T08:30:20.000Z","updated":"2022-03-29T07:08:36.266Z","comments":true,"path":"posts/DSP/correlation_analysis_1.html","link":"","permalink":"http://yoursite.com/posts/DSP/correlation_analysis_1.html","excerpt":"","text":"matlab中有函数xcorr可完成相关性分析，本文为加深理解，采用快速傅里叶变换进行了一次实现。 自相关分析实现 分析原理 工程上对信号相似程度的研究,可以使用以下公式进行分析。 Rxy(τ)=∫−∞+∞x(t)y(t+τ)dxR_{xy}(\\tau)=\\int^{+\\infty}_{-\\infty}{ x(t)y(t+\\tau)}dx Rxy​(τ)=∫−∞+∞​x(t)y(t+τ)dx 利用时域上的卷积等于频域的乘积则有 x(n)⟶FFTX(k)y(n)⟶FFTY(k)x(n)\\stackrel{FFT}{\\longrightarrow}X(k) \\\\ y(n)\\stackrel{FFT}{\\longrightarrow}Y(k) x(n)⟶FFT​X(k)y(n)⟶FFT​Y(k) Rxy(k)=X(k)Y‾(k)⇒Rxy(n)=Rxy(k)⟶IFFTRxy(n)\\begin{aligned} R_{xy}(k) &amp;= X(k)\\overline{Y}(k) \\\\ \\Rightarrow R_{xy}(n) &amp;= R_{xy}(k) \\stackrel{IFFT}{\\longrightarrow}R_{xy}(n) \\end{aligned} Rxy​(k)⇒Rxy​(n)​=X(k)Y(k)=Rxy​(k)⟶IFFT​Rxy​(n)​ FFT 计算引入周期延拓问题，为了避免重叠失真，补等宽的零，导致另外一个问题，相关系数越来越小，以零值为中心向两边衰减。 通过将每个信号除以偏移长度，可以得到一个无衰减的结果。 程序实现 由于时间原因未能编写出无偏修正的算法,以下为FFT实现的相关性分析程序 1234567891011121314151617181920212223242526272829303132function Rxy = xcorrfuction(datax,varargin) p = inputParser;%创建一个对象 %必填参数判断 p.addRequired('datax',@(x)validateattributes( x,&#123;'numeric'&#125;,&#123;'nonempty'&#125;)); %可选参数判断 p.addOptional('datay',datax,@(x)validateattributes(x,&#123;'numeric'&#125;,&#123;'nonempty'&#125;)); %无序选项判断 p.addParameter('option','biased',@(x)any(validatestring(x,'biased','unbiased'&#125;))); %将参数传入 p.parse(datax,varargin&#123;:&#125;); %下面开始计算 N1=length(p.Results.datax); N2=length(p.Results.datay); x1 = [p.Results.datax zeros(1,N1)]; y1 = [p.Results.datay zeros(1,N2)]; Rxy2 = ifft(fft(x1).*conj(fft(y1))); Rxy = fftshift(Rxy2); %选择无偏 if (strcmp(p.Results.option , 'unbiased')) N = length(Rxy)/2; for i = 1:N Rl(i) = Rxy(i)/i; Rr(i) = Rxy(i+N)/(N+1-i); end Rxy = [Rl Rr]; end end %x = xcorrfuction([1,2,3],'biased'); 实现效果 自相关分析效果 互相关效果","categories":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Matlab 谱减法降噪实现 (一)","slug":"DSP/spectral_subtraction_1","date":"2020-11-06T08:30:17.000Z","updated":"2022-03-29T07:19:11.734Z","comments":true,"path":"posts/DSP/spectral_subtraction_1.html","link":"","permalink":"http://yoursite.com/posts/DSP/spectral_subtraction_1.html","excerpt":"","text":"谱减法实现 降噪原理 谱减法的降噪方式简单来说就是从带噪声的语音频率信息中减去噪声频率的部分, 即从语音信号幅度谱中减去噪声的估值幅度谱, 相当于对噪声进行了均衡处理。 这里采用传统的谱减法进行实现 谱减法原理图 几个假设假设: 噪声在频域是加性的 背景噪声近似是稳态的 主要噪声可以仅仅通过语音普幅度中翘曲噪声实现 程序实现 首先根据输入参数不同进行函数重载 为了方便处理 ,将可能双通道的音频合成为单通道 ,记录在x中 matlab没有函数重载, 但可以通过 nargin 判断参数个数, 或者 inputParser 进行选择输入 1234567891011121314function dnY = denoise(y,fs,varargin)% % 使用方法% % denoise(SoundData,Frequency) 采用前2s静默段降噪% % denoise(SoundData,Frequency,NoiseData) 采用给定噪声样本降噪% % denoise(SoundData,Frequency,t1,t2) 采用前t1-t2时间内声段样本降噪(暂时未实现)narginchk(0,2);%检查输入参数%将输入音频修改为单声道if size(y,2) == 2 x = mean(y,2);else x = y;end 对长段音频信号直接进行分析是不太可取的, 并且也没有这个必要。因为短段语音信息可以认为是稳定的, 所以我们可以对音频信号进行分帧处理, 一般每帧长度取 20-30ms 因为直接截断相当于添加了一个矩形窗函数, 矩形窗函数的旁瓣较高, 频率泄漏相较严重, 所以为每段信号加上汉宁窗, 可以缓解频率泄漏。 由于汉宁窗会丢失掉前后一部分的信息,所以每次移动窗的距离, 取12\\frac{1}{2}21​或者13\\frac{1}{3}31​窗长作为移窗距离, 以便在前后窗可以补全缺失的信息。 对语音信息进行快速傅里叶变换得到频谱数据, 因为人耳对相位信息不敏感, 故可以记录带噪声时的相位信息, 用作降噪后还原语音信息。 12345678910111213%对信号进行分帧处理SizeX = length(x);wl = floor(0.03*fs); %帧长度，每帧30mswm = floor(wl/2); %移动长度N = floor((SizeX-wl)/wm);%总帧数%加窗分析for i = 1:N xh=x((i-1)*wm+1:(i-1)*wm+wl).*hamming(wl); XH=fft(xh,wl);%取单边谱 PSD(i,:)=abs(XH).^2;%计算每帧功率谱 phase(i,:)=angle(XH);%记录相位信息end 假设语音数据 Yw(w)Y_w(w)Yw​(w) 包括目标声音数据 Sw(w)S_w(w)Sw​(w) 和噪声 Nw(w)N_w(w)Nw​(w) 则对于功率谱有 ∣Yw(w)∣2=∣Sw(w)∣2+∣Nw(w)∣2+Sw(w)Nw∗(w)+Sw∗(w)Nw(w)|Y_w(w)|^2 = |S_w(w)|^2+|N_w(w)|^2 +S_w(w)N^*_w(w)+S^*_w(w)N_w(w) ∣Yw​(w)∣2=∣Sw​(w)∣2+∣Nw​(w)∣2+Sw​(w)Nw∗​(w)+Sw∗​(w)Nw​(w) ​ 假设 sss 和 nnn 相互独立, 则相互统计均值为零, 可以估计原始目标数据为 ∣S^w(w)∣2=∣Yw(w)∣2−E(∣Nw(w)∣2)|\\hat{S}_w(w)|^2=|Y_w(w)|^2-E(|N_w(w)|^2) ∣S^w​(w)∣2=∣Yw​(w)∣2−E(∣Nw​(w)∣2) 当输入参数为3个时,意味着输入了参考噪声信息 ,采取上述相同的操作获得噪声的功率谱估计值E(∣Nw(w)∣2)E(|N_w(w)|^2)E(∣Nw​(w)∣2) 这里发现估计的噪声功率普均衡效果不佳, 故这里仅仅通过乘以了一个系数以提高效果, 效果稍微好了一些, 但是目标声音也受到了一定影响, 可能通过其他算法可以优化. 123456789101112131415161718192021222324252627282930313233switch nargin %采用前端静默消声 case 2 %noiseP = sum(PSD(68:134,:))/67;%取前1-2s计算噪声功率 noiseP = (sum(PSD(68:134,:))/67).*3;%(不知为什么乘以2之后效果更好了) %采用其他噪声样本数据消声 case 3 noisedata = varargin&#123;1&#125;; if size(noisedata,2) == 2 Noise = mean(noisedata,2); else Noise = noisedata; end SizeN = length(Noise); wlN = floor(0.03*fs); %帧长度，每帧30ms wmN = floor(wlN/2); %移动长度 NN = floor((SizeN-wlN)/wmN);%总帧数 for i = 1:NN nh=Noise((i-1)*wmN+1:(i-1)*wmN+wlN).*hamming(wlN); NH=fft(nh,wlN);%取单边谱 NPSD(i,:)=abs(NH).^4;%计算每帧功率谱 end noiseP = sum(NPSD(71:NN-70,:))/(NN-140).*3; %noiseP = sum(NPSD(71:NN-70,:))/(NN-140);end%频减处理for i = 1:N PSD(i,:) = PSD(i,:)-noiseP; PSD(i,find(PSD(i,:)&lt;0))=0;%噪声平均功率大于实际的置零end 对处理后的信息进行逆变换(返回频谱、添加相位信息、傅里叶逆变换、消窗), 得到目标语音帧. 对每帧语音进行平滑合并 ,得到目标语音 1234567891011121314151617%消窗，返回语音组for i = 1:N PSD(i,:)=sqrt(PSD(i,:));%返回频谱 XHA = PSD(i,:).*exp(j*ang(i,:));%添加相位信息 dnx(i,:) = real(ifft(XHA))/hamming(wl)';%逆傅里叶，去窗end%合并语音组dny = dnx(1,:)';%第一个语音组存入dnypbeg = wl-wm;pend = wl;%初始化指针指向重叠段末尾for i = 2:N dny(pbeg:pend) = (dny(pbeg:pend)+dnx(i,1:wm)')/2; dny=[dny;dnx(i,wl-wm:wl)'];% pbeg = pbeg+wl; pend = pend+wl;end 实现效果 采用前1-2s内噪声信息进行消声 采用额外噪声信息进行消声","categories":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"Matlab数据文件读/写","slug":"matlab/Matlabfile_IO","date":"2020-09-18T06:40:17.000Z","updated":"2022-03-17T10:01:46.842Z","comments":true,"path":"posts/matlab/Matlabfile_IO.html","link":"","permalink":"http://yoursite.com/posts/matlab/Matlabfile_IO.html","excerpt":"","text":"测试数据经常使用 matal 进行处理，在此保存一份读/写文件模板方便以后使用 基本操作过程 1.测试数据读入 采集卡得到的的数据大部分可以以.txt文件列向量的形式得到，删除数据描述部分后，可以使用以下语句读入为列向量。 1[x,y]=textread('Path',' %f %f'); 2.数据处理 之后可以通过不同的处理手段，对数据进行（不限于）以下的操作 数值处理 图像绘制 3.数据导出 处理完毕后可以将数据以.txt文件输出，给后续计算/处理使用 12345678%写入文件路径fid=fopen('D:\\Project\\Graduation Design\\Matlab\\MiX_Z_L.txt','wt');for i = 1:1:1000 fprintf(fid,'%d ',f(i)); fprintf(fid,'&#123;%f %f&#125;\\n',arr1(i),arr2(i));endfclose(fid); 多文件处理模板 这里以某次处理振动加速的得到速度的过程作为案例； 数据文件采用统一命名规则，可以方便利用循环语句快速导入数据 123456789101112131415161718192021222324252627direction=[\"x\",\"y\",\"z\"];pressure=[\"150\",\"50\"];for i=1:length(pressure) for j = 1:length(direction) fname_in=\"\\T02_\"+pressure(i)+\"_\"+direction(j)+\".txt\"; path=\"D:\\works\\duct_analize\\vib_\"+pressure(i)+... \"\\outlet2_\"+pressure(i); %得到\"D:\\works\\duct_analize\\vib_50\\outlet2_50\\T02_50_z.txt\" [num,t,a]=textread( char(path+fname_in) ,' %d %f %f'); za=detrend(a); %对采集到的加速度信号去趋势处理(采集加速度信号有直流偏移量) vz=cumtrapz(t(2),za); %对加速度信号积分得速度信号 v=detrend(vz); %写入文件路径同样可以使用命名规则 fname_out = \"\\T02_\"+pressure(i)+\"_\"+direction(j)+\"vel.txt\"; fid=fopen('D:\\works\\duct_vibration\\test\\vib_vel\\'+fname_out,'wt'); for n = 1:length(vz) fprintf(fid,'%d ',num(n)); fprintf(fid,'%f %f\\n',t(n),v(n)); end fclose(fid); hold on; plot(t,v); end end","categories":[{"name":"数据处理","slug":"数据处理","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"}]},{"title":"C++Primer 16章·11-20","slug":"cpp/cpp-16-2","date":"2020-09-09T01:09:17.000Z","updated":"2022-03-17T10:01:46.787Z","comments":true,"path":"posts/cpp/cpp-16-2.html","link":"","permalink":"http://yoursite.com/posts/cpp/cpp-16-2.html","excerpt":"","text":"16.11 List的定义是错误的，应该如何修正？ 修改后： 123456789101112template &lt;typename elemType&gt; class ListItem;template &lt;typename elemType&gt; class List &#123;public: List();//在List模板内调用List可以省略&lt;&gt; List(const List&lt;elemType&gt; &amp;); List&amp; operator=(const List&lt;elemType&gt;&amp;); ~List(); //ListItem在模板类定义外调用需要加上&lt;&gt; void insert(ListItem&lt;elemType&gt;* ptr, elemType value);private: ListItem * front, * end;&#125;; 16.12 编写你自己版本的Blob和BlobPtr，包含书中未定义的多个const 这道题涉及到新学的模板类的定义和模板友元的声明以及之前学到的const类型函数、智能指针、运算符重载等内容。如果跟我一样战线拉得比较长得同学可以试着重写以下这个Blob。如果之前学得比较好的话，可以直接从12章-19题的Strbol.h改成template模板熟悉一下模板的声明。程序如下： blob.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#ifndef BLOB_H#define BLOB_H#include&lt;vector&gt;#include&lt;string&gt;#include&lt;memory&gt;#include&lt;initializer_list&gt;using namespace std;template &lt;typename t&gt; class blobptr;template &lt;typename T&gt; bool operator==(const blobptr&lt;T&gt;&amp;, const blobptr&lt;T&gt;&amp;);template&lt;typename T&gt; class blob &#123; friend class blobptr&lt;T&gt;;public: blob(); blob(initializer_list&lt;T&gt; il);//接受&#123;&#125;列表初始化 string::size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; void push_back(const T&amp; t) &#123; data-&gt;push_back(t); &#125; void push_back(const T&amp;&amp; t) &#123; data-&gt;push_back(t); &#125; void pop_back(); T&amp; front(); const T&amp; front()const; T&amp; back(); const T&amp; back()const; T&amp; operator[](string::size_type i); const T&amp; operator[](string::size_type i) const; //与书上不同，改为了const版本， //同时blobptr构造函数的接受参数也要改为const版本的引用 blobptr&lt;T&gt; begin() const &#123;return blobptr&lt;T&gt;(*this);&#125; blobptr&lt;T&gt; end() const &#123;return blobptr&lt;T&gt;(*this,data-&gt;size());&#125;private: shared_ptr&lt;vector&lt;T&gt;&gt; data; void check(string::size_type i,const string&amp; s)const;//检查溢出&#125;;template&lt;typename T&gt; blob&lt;T&gt;::blob() : data(make_shared&lt;vector&lt;T&gt;&gt;())&#123;&#125;template&lt;typename T&gt; blob&lt;T&gt;::blob(initializer_list&lt;T&gt; il): data(make_shared&lt;vector&lt;T&gt;&gt;(il))&#123;&#125;template&lt;typename T&gt; void blob&lt;T&gt;::pop_back() &#123; check(0, \"no elem here\"); return data-&gt;pop_back();&#125;template&lt;typename T&gt; T&amp; blob&lt;T&gt;::back() &#123; check(0, \"no elem here\"); return data-&gt;back();&#125;template&lt;typename T&gt; const T&amp; blob&lt;T&gt;::back()const &#123; check(0, \"no elem here\"); return data-&gt;back();&#125;template&lt;typename T&gt; T&amp; blob&lt;T&gt;::front() &#123; check(0, \"no elem here\"); return data-&gt;front();&#125;template&lt;typename T&gt; const T&amp; blob&lt;T&gt;::front()const &#123; check(0, \"no elem here\"); return data-&gt;front();&#125;template&lt;typename T&gt; T&amp; blob&lt;T&gt;::operator[](string::size_type i) &#123; check(i, \"out of range\"); return (*data)[i];&#125;template&lt;typename T&gt; const T&amp; blob&lt;T&gt;::operator[](string::size_type i)const &#123; check(i, \"out of range\"); return (*data)[i];&#125;template&lt;typename T&gt; void blob&lt;T&gt;::check(string::size_type i, const string&amp; s)const &#123; if (i &gt;= data-&gt;size()) throw out_of_range(s);&#125;//blobptr相当于一个blob的迭代器template &lt;typename t&gt; class blobptr &#123; friend bool operator==&lt;t&gt;(const blobptr&lt;t&gt;&amp; lhr, const blobptr&lt;t&gt;&amp; rhr);public: blobptr():curr(0)&#123;&#125; blobptr( const blob&lt;t&gt; &amp;pb ,const size_t sz = 0):wptr(pb.data),curr(sz)&#123;&#125; t &amp; operator*() const; blobptr &amp; operator++();private: shared_ptr&lt;vector&lt;t&gt;&gt; check(const size_t sz,string msg) const; weak_ptr&lt;vector&lt;t&gt;&gt; wptr; size_t curr;&#125;;template &lt;typename t&gt;shared_ptr&lt;vector&lt;t&gt;&gt; blobptr&lt;t&gt;::check(const size_t sz,string msg)const &#123; auto ret = wptr.lock(); if(!ret) throw runtime_error(\"unbond\"); else if(sz &gt;= ret-&gt;size()) throw out_of_range(msg); return ret;&#125;template &lt;typename t&gt;t &amp; blobptr&lt;t&gt;::operator*()const&#123; auto pb = check(curr,\"out of range\"); return (*pb)[curr];&#125;template &lt;typename t&gt;blobptr&lt;t&gt; &amp; blobptr&lt;t&gt;::operator++()&#123; check(curr,\"the end\"); ++curr; return *this;&#125;template &lt;typename T&gt; bool operator==(const blobptr&lt;T&gt;&amp; lhr, const blobptr&lt;T&gt;&amp; rhr) &#123; return (lhr.curr == rhr.curr );&#125;#endif // !BLOB_H main.cpp 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string&gt;#include\"blob.h\"using namespace std;int main(int argc, char** argv) &#123; //测试 blob 功能(int) cout &lt;&lt; \"普通版本功能测试\" &lt;&lt; endl; blob&lt;int&gt; a = &#123;1,2,3,4,5,6,7,8&#125;; cout &lt;&lt; a.back() &lt;&lt; endl; cout &lt;&lt; a[2] &lt;&lt; endl; //测试 blobptr 功能(string) blob&lt;string&gt; b = &#123; \"abc\",\"def\",\"ghi\",\"jkl\" &#125;; blobptr&lt;string&gt; ib2(b, 2); cout &lt;&lt; *ib2 &lt;&lt; endl; auto ib = b.begin();//合成版本拷贝 cout&lt;&lt; *ib &lt;&lt;endl; cout&lt;&lt; *(++ib) &lt;&lt;endl; //检测const版本 cout &lt;&lt; \"const版本功能测试\" &lt;&lt; endl; const blob&lt;int&gt; ca = &#123; 1,2,3,4,5,6,7,8 &#125;; cout &lt;&lt; ca.back() &lt;&lt; endl; cout &lt;&lt; ca[2] &lt;&lt; endl; const blob&lt;string&gt; cb = &#123; \"abc\",\"def\",\"ghi\",\"jkl\" &#125;; auto icb = cb.begin(); cout &lt;&lt; *icb &lt;&lt; endl;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"}]},{"title":"C++练习-16章·1-10","slug":"cpp/cpp-16-1","date":"2020-09-08T01:09:17.000Z","updated":"2022-03-17T10:01:46.786Z","comments":true,"path":"posts/cpp/cpp-16-1.html","link":"","permalink":"http://yoursite.com/posts/cpp/cpp-16-1.html","excerpt":"","text":"声明：以下练习均为个人编写，非标准答案，可能存在错误，欢迎各位交流讨论，指出错误！ 16.1 实例化的定义 当调用一个函数模板时，编译器用函数实参来为我们推断模板实参，使用模板实参的类型来确定绑定到模板参数T的类型建立出模板的一个新实例。 16.2编写并测试你自己版本的compare函数。 head.h 1234567891011#ifndef compare_h#define compare_h#include&lt;functional&gt;template &lt;typename T&gt;int compare(const T&amp; v1, const T&amp; v2) &#123; if (std::less&lt;T&gt;()(v1, v2)) return 1;//这里相当于使用()生成less&lt;T&gt;的临时可调用对象 if (std::less&lt;T&gt;()(v2, v1)) return -1; return 0;&#125;#endif // !compare_h main.cpp 12345678910111213#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;functional&gt;#include\"head.h\"using namespace std;int main(int argc, char** argv)&#123; cout &lt;&lt; compare('a', 'b') &lt;&lt; endl; cout &lt;&lt; compare(4, 4) &lt;&lt; endl; cout &lt;&lt; compare(6, 5) &lt;&lt; endl;&#125; 16.3对两个Sales_data对象调用compare函数，观察编译器在实例化过程中如何处理错误。 找不到Sales_data放哪了，下次补上。 16.4编写类似find算法的模板。使用函数在一个vector&lt;int&gt;和list&lt;string&gt;中查找给定值 findkey.h 123456789101112#ifndef find_h#define find_htemplate &lt;typename T, typename X&gt;const T findkey(const T&amp; beg, const T&amp; ed, const X&amp; key) &#123; for (auto ik = beg; ik != ed; ++ik) &#123; if (*ik == key) return ik; &#125; return ed;&#125;#endif // !find_h main.cpp 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;list&gt;#include\"findkey.h\"using namespace std;int main(int argc, char** argv)&#123; vector&lt;int&gt; a = &#123; 1,2,3,4,5,6,7,8,9,0 &#125;; list&lt;string&gt; b = &#123; \"'a\",\"b\",\"c\",\"d\",\"e\",\"f\" &#125;; auto pw = findkey(a.begin(), a.end(), 5); if (pw != a.end()) cout &lt;&lt; *pw &lt;&lt; endl; else cout &lt;&lt; \"no find\" &lt;&lt; endl; auto ps = findkey(b.begin(), b.end(), \"k\"); if (ps != b.end()) cout &lt;&lt; *ps &lt;&lt; endl; else cout &lt;&lt; \"no find\" &lt;&lt; endl;&#125; 16.5-7 这几个太简单了，以后有时间再补 16.8 为什么C++程序员喜欢用!=而不喜欢&lt;。解释原因。 因为大部分的类型都定义了!=运算符，但是不一定定义&lt;运算符 16.9什么是函数模板？什么是类模板？ 函数模板是一个可用来生成针对特定类型的函数版本的公式。类模板则是生成特定的类，但是不能想函数模板那样推断参数类型，需要使用尖括号提供。 16.10当一个类模板被实例化时，会发生什么？ 编译器将会重写该模板，并将模板参数T的每个实例替换为给定的模板实参，例如int。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"}]},{"title":"关于如何添加链接工具图标","slug":"hexo/help-tooltip","date":"2020-08-24T13:45:34.000Z","updated":"2022-03-29T06:54:06.729Z","comments":true,"path":"posts/hexo/help-tooltip.html","link":"","permalink":"http://yoursite.com/posts/hexo/help-tooltip.html","excerpt":"","text":"前言 本文所写的iconfont添加方案适用于在模板已有自定义字体库的情况下额外添加图形字体。若是此前无其他字体库，可以跳过第二部单独添加，但除临时页面，仍建议使用项目进行图标管理。 第一步 登录可以，iconfont（ https://www.iconfont.cn/ ）挑选需要的矢量文字图形。将挑选好的图形加入库中（图标像购物车），可以挑选多个。 第二步 这一步可以防止unicode重复导致在blog中图形引用错误。 点击库（购物车），将图标文件添加到我的项目，如果还没有的话可以点击右上角小图标新建。 在 资源管理-&gt;我的项目 中找到自己选好的图标，选择编辑图标。 在编辑页面中可以看到图标的unicode和引用名，我们可以对unicode手动进行修改，以免出现与现有文字图库unicode重复造成的问题。 已经使用的unicode可以在主题的.css文件中查找。打开blog主题文字样式的.css文件,我在这里使用的是基于pure主题修改的主题，样式文件为…\\pure\\source\\css\\style.css 可以使用Ctrl+F判断unicode是否被占用，若已经占用了，按照上面说的修改为一个未被占用的，然后点击保存就好了。 第三步 修改完成之后，再次将图标加入库，点击下载到本地。 将文件夹解压后，将图中红色箭头所指的5个文件重命名，然后将其复制到主题文字样式文件夹，我的样式中为…/source/fonts（增加相同后缀，不与fonts中的文件重名即可） 打开蓝色箭头所指的iconfont.css文件，将代码复制到主题的文字样式文件.css中，将图中红线所示的url修改为刚刚我们修改（添加后缀）后的文件名。 将图中蓝箭头的font-family名称（新添加的图标）改成与原来的font-family名称一致（黄色箭头），保存。 第四步 到这一步的话已经添加完成了，可以像调用其他图标一样，在主题样式文件_config.yml中调用了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","slug":"hexo/hello-world","date":"2020-07-01T03:34:46.883Z","updated":"2022-03-17T10:01:46.830Z","comments":false,"path":"posts/hexo/hello-world.html","link":"","permalink":"http://yoursite.com/posts/hexo/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment comments: false","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"post","slug":"post","permalink":"http://yoursite.com/tags/post/"}]}],"categories":[{"name":"AMEsim","slug":"AMEsim","permalink":"http://yoursite.com/categories/AMEsim/"},{"name":"MYSQL数据库","slug":"MYSQL数据库","permalink":"http://yoursite.com/categories/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Sport","slug":"Sport","permalink":"http://yoursite.com/categories/Sport/"},{"name":"课外阅读","slug":"课外阅读","permalink":"http://yoursite.com/categories/%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB/"},{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"数据处理","slug":"数据处理","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/categories/Cpp/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"仿真","slug":"仿真","permalink":"http://yoursite.com/tags/%E4%BB%BF%E7%9C%9F/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://yoursite.com/tags/MYSQL/"},{"name":"Databased","slug":"Databased","permalink":"http://yoursite.com/tags/Databased/"},{"name":"运动","slug":"运动","permalink":"http://yoursite.com/tags/%E8%BF%90%E5%8A%A8/"},{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/%E9%87%91%E8%9E%8D/"},{"name":"信号处理","slug":"信号处理","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Matlab","slug":"Matlab","permalink":"http://yoursite.com/tags/Matlab/"},{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"post","slug":"post","permalink":"http://yoursite.com/tags/post/"}]}